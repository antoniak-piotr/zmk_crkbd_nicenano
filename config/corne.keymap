#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>

#define DEF 0           // QWERTY
#define EXT 1           // NUMBER & FUNCTION KEYS
#define NAV 2           // NAVIGATION
#define SYS 3           // SYSTEM (Bluetooth configuration, etc.)

#define SFT LSHFT
#define CTL LCTRL
#define ALT LALT

/ {
    keymap {
        compatible = "zmk,keymap";

            //  0       1               2               3               4               5                       6               7               8               9               10              11
        DEF {
            bindings = <
                &none   &none           &kp ESC         &kp W           &kp F           &kp G                   &kp M           &kp L           &kp U           &kp BSPC        &none   &none
                &none   &none           &kp TAB         &mt ALT A       &mt CTL R       &mt SFT S               &mt SFT N       &mt CTL E       &mt ALT I       &kp DEL         &none   &none
                &none   &none           &none           &kp C           &kp D           &kp T                   &kp H           &kp O           &kp Y           &none           &none   &none
                                                        &none           &mt LWIN EQUAL  &lt EXT UNDER           &lt NAV SPACE   &mt RALT ENTER  &none
            >;
        };

        EXT {
            bindings = <
                &none   &none           &kp ESC         &kp F1          &kp F2          &kp F3                  &kp N7          &kp N8          &kp N9          &kp BSPC        &none   &none
                &none   &none           &kp TAB         &mt ALT F4      &mt CTL F5      &mt SFT F6              &mt SFT N4      &mt CTL N5      &mt ALT N6      &kp DEL         &none   &none
                &none   &none           &none           &kp F7          &kp F8          &kp F9                  &kp N1          &kp N2          &kp N3          &none           &none   &none
                                                        &none           &mt LWIN EQUAL  &trans                  &lt NAV SPACE   &mt RALT ENTER  &none
            >;
        };

        NAV {
            bindings = <
                &none   &none           &kp ESC         &none           &none           &none                   &none           &none           &none           &kp BSPC        &none   &none
                &none   &none           &kp TAB         &none           &none           &none                   &kp LEFT        &kp UP          &kp RIGHT       &kp DEL         &none   &none
                &none   &none           &none           &none           &none           &none                   &kp LC(LEFT)    &kp DOWN        &kp LC(RIGHT)   &none           &none   &none
                                                        &none           &mt LWIN EQUAL  &lt EXT UNDER           &trans          &mt RALT ENTER  &none
            >;
        };
    };

    #define COMBO timeout-ms = <125>

    /*                KEY POSITIONS
    ╭────────────────────────╮ ╭────────────────────────╮
    │  0   1   2   3   4   5 │ │  6   7   8   9  10  11 │
    │ 12  13  14  15  16  17 │ │ 18  19  20  21  22  23 │
    │ 24  25  26  27  28  29 │ │ 30  31  32  33  34  35 │
    ╰───────────╮ 36  37  38 │ │ 39  40  41 ╭───────────╯
                ╰────────────╯ ╰────────────╯          */

    combos {
        compatible = "zmk,combos";

        // // CAPSLOCK, CAPSWORD, NUMWORD
        clck    {key-positions = <5 6>; bindings = <&kp CAPS>; layers = <DEF>; COMBO;};     // CAPSLOCK
        cwrd    {key-positions = <17 18>; bindings = <&caps_word>; layers = <DEF>; COMBO;}; // CAPSWORD
        // nwrd    {key-positions = <24 25>; bindings = <&num_word>; layers = <DEF COL>; COMBO;};                  // NUMWORD

        // MISSING LETTERS ON DEF LAYER
        dq      {key-positions = <3 4>; bindings = <&kp Q>; layers = <DEF>; COMBO;};
        db      {key-positions = <4 5>; bindings = <&kp B>; layers = <DEF>; COMBO;};
        dz      {key-positions = <27 28>; bindings = <&kp Z>; layers = <DEF>; COMBO;};
        dx      {key-positions = <28 29>; bindings = <&kp X>; layers = <DEF>; COMBO;};

        dj      {key-positions = <6 7>; bindings = <&kp J>; layers = <DEF>; COMBO;};
        dp      {key-positions = <7 8>; bindings = <&kp P>; layers = <DEF>; COMBO;};
        dv      {key-positions = <30 31>; bindings = <&kp V>; layers = <DEF>; COMBO;};
        dk      {key-positions = <31 32>; bindings = <&kp K>; layers = <DEF>; COMBO;};

        // MISSING NUMBERS AND FUNCTION KEYS ON EXT LAYER
        ef10    {key-positions = <15 27>; bindings = <&kp F10>; layers = <EXT>; COMBO;};
        ef11    {key-positions = <16 28>; bindings = <&kp F11>; layers = <EXT>; COMBO;};
        ef12    {key-positions = <17 29>; bindings = <&kp F12>; layers = <EXT>; COMBO;};
        en0     {key-positions = <30 31>; bindings = <&kp N0>; layers = <EXT>; COMBO;};

        // GRAVE, APOS
        grave   {key-positions = <5 17>; bindings = <&kp GRAVE>; layers = <DEF>; COMBO;};
        apos    {key-positions = <6 18>; bindings = <&kp APOS>; layers = <DEF>; COMBO;};

        // DOT, COMMA
        dot     {key-positions = <17 29>; bindings = <&dot>; layers = <DEF>; COMBO;};       // .:
        comma   {key-positions = <18 30>; bindings = <&comma>; layers = <DEF>; COMBO;};     // ,;

        // PAR, BKT, BRC, etc.
        lpar    {key-positions = <19 31>; bindings = <&lpar>; layers = <DEF>; COMBO;};      // (< [{
        rpar    {key-positions = <20 32>; bindings = <&rpar>; layers = <DEF>; COMBO;};      // )> ]}

        // PLUS, MUL, MINUS, DIV
        plus    {key-positions = <15 27>; bindings = <&plus>; layers = <DEF>; COMBO;};      // +*
        minus   {key-positions = <16 28>; bindings = <&minus>; layers = <DEF>; COMBO;};     // -/

        // OTHER SYMBOLS
        excl    {key-positions = <3 15>; bindings = <&excl>; layers = <DEF>; COMBO;};       // !?
        hash    {key-positions = <4 16>; bindings = <&hash>; layers = <DEF>; COMBO;};       // #$
        caret   {key-positions = <7 19>; bindings = <&caret>; layers = <DEF>; COMBO;};      // ^@
        amps    {key-positions = <8 20>; bindings = <&amps>; layers = <DEF>; COMBO;};       // &|
    };

    #define MORPH(NAME, BINDING1, BINDING2, MODS) \
        NAME: NAME { \
            compatible = "zmk,behavior-mod-morph"; #binding-cells = <0>; \
            bindings = <BINDING1>, <BINDING2>; \
            mods = <(MODS)>; \
        };

    // #define MORPH(NAME, BINDING1, BINDING2, MODS, KEEPMODS) \
    //     NAME: NAME { \
    //         compatible = "zmk,behavior-mod-morph"; #binding-cells = <0>; \
    //         bindings = <BINDING1>, <BINDING2>; \
    //         mods = <(MODS)>; \
    //         keep-mods = <(KEEPMODS)>; \
    //     };

    #define HOLD(NAME, BINDING1, BINDING2) \
        NAME: NAME { \
            compatible = "zmk,behavior-hold-tap"; #binding-cells = <2>; tapping-term-ms = <200>; quick-tap-ms = <175>; \
            bindings = <BINDING1>, <BINDING2>; \
            flavor = "balanced"; \
        };

    // #define HOLD(NAME, BINDING1, BINDING2, FLAVOR) \
    //     NAME: NAME { \
    //         compatible = "zmk,behavior-hold-tap"; #binding-cells = <2>; tapping-term-ms = <200>; quick-tap-ms = <175>; \
    //         bindings = <BINDING1>, <BINDING2>; \
    //         flavor = "FLAVOR"; \
    //     };

    behaviors {
        MORPH(mequal,   &kp EQUAL,  &assign,            MOD_LSFT|MOD_RSFT)
        HOLD(equal,     &kp,   &mequal)

        MORPH(sdot,     &kp DOT,    &kp COLON,          MOD_LSFT|MOD_RSFT)
        MORPH(scomma,   &kp COMMA,  &kp SEMI,           MOD_LSFT|MOD_RSFT)
        MORPH(dot,      &sdot,      &kp BSLH,           MOD_LCTL|MOD_RCTL)
        MORPH(comma,    &scomma,    &mt LC(FSLH) FSLH,  MOD_LCTL|MOD_RCTL)

        MORPH(plus,     &kp PLUS,   &kp STAR,           MOD_LSFT|MOD_RSFT)
        MORPH(minus,    &kp MINUS,  &kp SLASH,          MOD_LSFT|MOD_RSFT)

        MORPH(excl,     &kp EXCL,   &kp QMARK,          MOD_LSFT|MOD_RSFT)
        MORPH(hshdlr,   &kp HASH,   &kp DLLR,           MOD_LSFT|MOD_RSFT)
        MORPH(hash,     &hshdlr,    &kp PRCNT,          MOD_LCTL|MOD_RCTL)
        MORPH(caret,    &kp CARET,  &kp AT,             MOD_LSFT|MOD_RSFT)
        MORPH(amps,     &kp AMPS,   &kp PIPE,           MOD_LSFT|MOD_RSFT)

        MORPH(lplt,     &kp LPAR,   &kp LT,             MOD_LSFT|MOD_RSFT)
        MORPH(rpgt,     &kp RPAR,   &kp GT,             MOD_LSFT|MOD_RSFT)
        MORPH(lpar,     &lplt,      &kp LBKT,           MOD_LCTL|MOD_RCTL)
        MORPH(rpar,     &rpgt,      &kp RBKT,           MOD_LCTL|MOD_RCTL)
    };

    macros {
        assign: delphi_assign_operator_macro { // colon-equal operator
            #binding-cells = <0>;
            compatible = "zmk,behavior-macro";
            bindings = <&macro_tap &kp COLON>, <&macro_tap &kp EQUAL>;
        };

        // dcfm: delphi_code_folding_macro { // code block folding
        //     #binding-cells = <1>;
        //     compatible = "zmk,behavior-macro-one-param";
        //     bindings =
        //         <&macro_press &kp LSHFT &kp LCTRL>,
        //         <&macro_tap &kp K>,
        //         <&macro_param_1to1 &kp MACRO_PLACEHOLDER>,
        //         <&macro_release &kp LSHFT &kp LCTRL>;
        // };
    };
};
